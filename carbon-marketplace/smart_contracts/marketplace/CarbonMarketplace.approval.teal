#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 1 0 8 2
    bytecblock "business_verified" "admin" "total_volume_microalgo" "total_trades" "total_credits_bought" 0x151f7c75 "platform_fee_bps"
    // smart_contracts/marketplace/contract.py:18
    // class CarbonMarketplace(ARC4Contract):
    txn OnCompletion
    !
    assert
    txn ApplicationID
    bz main_create_NoOp@15
    pushbytess 0x191db94e 0xaa5e221f 0x4ba7d851 0x61d9976d 0x0063320f 0x63d55b6c 0x790a7d24 0x0b10ef45 0xe67daf51 // method "register_business(string,string)void", method "verify_business(address)void", method "reject_business(address)void", method "list_credit(uint64,uint64,uint64,uint64,string,string,uint64,string)void", method "buy_credit(uint64)void", method "cancel_listing(uint64)void", method "get_listing(uint64)(address,uint64,uint64,uint64,uint64)", method "get_business_status(address)(uint64,uint64)", method "get_stats()(uint64,uint64)"
    txna ApplicationArgs 0
    match register_business verify_business reject_business list_credit buy_credit cancel_listing get_listing get_business_status get_stats
    err

main_create_NoOp@15:
    // smart_contracts/marketplace/contract.py:18
    // class CarbonMarketplace(ARC4Contract):
    pushbytes 0xca0b3ceb // method "create_marketplace(uint64)void"
    txna ApplicationArgs 0
    match create_marketplace
    err


// smart_contracts.marketplace.contract.CarbonMarketplace.create_marketplace[routing]() -> void:
create_marketplace:
    // smart_contracts/marketplace/contract.py:51
    // @arc4.abimethod(allow_actions=["NoOp"], create="require")
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/marketplace/contract.py:57
    // self.admin.value                  = Txn.sender
    bytec_1 // "admin"
    txn Sender
    app_global_put
    // smart_contracts/marketplace/contract.py:58
    // self.platform_fee_bps.value       = fee_bps.native
    btoi
    bytec 6 // "platform_fee_bps"
    swap
    app_global_put
    // smart_contracts/marketplace/contract.py:59
    // self.total_volume_microalgo.value = UInt64(0)
    bytec_2 // "total_volume_microalgo"
    intc_1 // 0
    app_global_put
    // smart_contracts/marketplace/contract.py:60
    // self.total_trades.value           = UInt64(0)
    bytec_3 // "total_trades"
    intc_1 // 0
    app_global_put
    // smart_contracts/marketplace/contract.py:51
    // @arc4.abimethod(allow_actions=["NoOp"], create="require")
    intc_0 // 1
    return


// smart_contracts.marketplace.contract.CarbonMarketplace.register_business[routing]() -> void:
register_business:
    // smart_contracts/marketplace/contract.py:67
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 2
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    // smart_contracts/marketplace/contract.py:78
    // self.business_name[Txn.sender]           = name.bytes
    txn Sender
    pushbytes "business_name"
    uncover 3
    app_local_put
    // smart_contracts/marketplace/contract.py:79
    // self.business_country[Txn.sender]         = country.bytes
    txn Sender
    pushbytes "business_country"
    uncover 2
    app_local_put
    // smart_contracts/marketplace/contract.py:80
    // self.business_verified[Txn.sender]        = UInt64(0)   # pending
    txn Sender
    bytec_0 // "business_verified"
    intc_1 // 0
    app_local_put
    // smart_contracts/marketplace/contract.py:81
    // self.total_credits_bought[Txn.sender]     = UInt64(0)
    txn Sender
    bytec 4 // "total_credits_bought"
    intc_1 // 0
    app_local_put
    // smart_contracts/marketplace/contract.py:82
    // self.total_credits_retired[Txn.sender]    = UInt64(0)
    txn Sender
    pushbytes "total_credits_retired"
    intc_1 // 0
    app_local_put
    // smart_contracts/marketplace/contract.py:67
    // @arc4.abimethod
    intc_0 // 1
    return


// smart_contracts.marketplace.contract.CarbonMarketplace.verify_business[routing]() -> void:
verify_business:
    // smart_contracts/marketplace/contract.py:85
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    pushint 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/marketplace/contract.py:88
    // assert Txn.sender == self.admin.value, "Admin only"
    txn Sender
    intc_1 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    assert // Admin only
    // smart_contracts/marketplace/contract.py:89
    // self.business_verified[business.native] = UInt64(1)
    bytec_0 // "business_verified"
    intc_0 // 1
    app_local_put
    // smart_contracts/marketplace/contract.py:85
    // @arc4.abimethod
    intc_0 // 1
    return


// smart_contracts.marketplace.contract.CarbonMarketplace.reject_business[routing]() -> void:
reject_business:
    // smart_contracts/marketplace/contract.py:92
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    pushint 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/marketplace/contract.py:95
    // assert Txn.sender == self.admin.value, "Admin only"
    txn Sender
    intc_1 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    assert // Admin only
    // smart_contracts/marketplace/contract.py:96
    // self.business_verified[business.native] = UInt64(2)   # 2 = rejected
    bytec_0 // "business_verified"
    intc_3 // 2
    app_local_put
    // smart_contracts/marketplace/contract.py:92
    // @arc4.abimethod
    intc_0 // 1
    return


// smart_contracts.marketplace.contract.CarbonMarketplace.list_credit[routing]() -> void:
list_credit:
    // smart_contracts/marketplace/contract.py:103
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 5
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 6
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 7
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 8
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    // smart_contracts/marketplace/contract.py:126
    // assert price_microalgo.native > UInt64(0), "Price must be > 0"
    uncover 4
    btoi
    dup
    assert // Price must be > 0
    // smart_contracts/marketplace/contract.py:127
    // assert min_purchase_qty.native > UInt64(0), "Min purchase must be > 0"
    uncover 2
    btoi
    dup
    assert // Min purchase must be > 0
    // smart_contracts/marketplace/contract.py:128
    // assert min_purchase_qty.native <= co2_tonnes.native, "Min qty cannot exceed total tonnes"
    uncover 4
    btoi
    dup2
    <=
    assert // Min qty cannot exceed total tonnes
    // smart_contracts/marketplace/contract.py:129
    // assert Txn.group_index > UInt64(0), "Must be in atomic group"
    txn GroupIndex
    assert // Must be in atomic group
    // smart_contracts/marketplace/contract.py:131-132
    // # Verify previous txn sent NFT to this contract
    // prev = gtxn.AssetTransferTransaction(Txn.group_index - UInt64(1))
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    // smart_contracts/marketplace/contract.py:133
    // assert prev.asset_receiver == Global.current_application_address, "NFT must go to contract"
    dup
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert // NFT must go to contract
    // smart_contracts/marketplace/contract.py:134
    // assert prev.xfer_asset.id  == asset_id.native, "Wrong asset ID"
    dup
    gtxns XferAsset
    uncover 7
    btoi
    swap
    dig 1
    ==
    assert // Wrong asset ID
    // smart_contracts/marketplace/contract.py:135
    // assert prev.asset_amount   == UInt64(1), "Must send exactly 1 NFT"
    dig 1
    gtxns AssetAmount
    intc_0 // 1
    ==
    assert // Must send exactly 1 NFT
    // smart_contracts/marketplace/contract.py:136
    // assert prev.sender         == Txn.sender, "Sender mismatch"
    swap
    gtxns Sender
    txn Sender
    ==
    assert // Sender mismatch
    // smart_contracts/marketplace/contract.py:153
    // op.itob(asset_id.native),
    itob
    // smart_contracts/marketplace/contract.py:154-155
    // op.itob(asset_id.native)          +   # 0:8
    // Txn.sender.bytes                  +   # 8:40
    dup
    // smart_contracts/marketplace/contract.py:155
    // Txn.sender.bytes                  +   # 8:40
    txn Sender
    // smart_contracts/marketplace/contract.py:154-155
    // op.itob(asset_id.native)          +   # 0:8
    // Txn.sender.bytes                  +   # 8:40
    concat
    // smart_contracts/marketplace/contract.py:156
    // op.itob(price_microalgo.native)   +   # 40:48
    uncover 4
    itob
    // smart_contracts/marketplace/contract.py:154-156
    // op.itob(asset_id.native)          +   # 0:8
    // Txn.sender.bytes                  +   # 8:40
    // op.itob(price_microalgo.native)   +   # 40:48
    concat
    // smart_contracts/marketplace/contract.py:157
    // op.itob(co2_tonnes.native)        +   # 48:56
    uncover 2
    itob
    // smart_contracts/marketplace/contract.py:154-157
    // op.itob(asset_id.native)          +   # 0:8
    // Txn.sender.bytes                  +   # 8:40
    // op.itob(price_microalgo.native)   +   # 40:48
    // op.itob(co2_tonnes.native)        +   # 48:56
    concat
    // smart_contracts/marketplace/contract.py:158
    // op.itob(vintage_year.native)      +   # 56:64
    uncover 4
    btoi
    itob
    // smart_contracts/marketplace/contract.py:154-158
    // op.itob(asset_id.native)          +   # 0:8
    // Txn.sender.bytes                  +   # 8:40
    // op.itob(price_microalgo.native)   +   # 40:48
    // op.itob(co2_tonnes.native)        +   # 48:56
    // op.itob(vintage_year.native)      +   # 56:64
    concat
    // smart_contracts/marketplace/contract.py:159
    // op.itob(min_purchase_qty.native)  +   # 64:72
    uncover 2
    itob
    // smart_contracts/marketplace/contract.py:154-159
    // op.itob(asset_id.native)          +   # 0:8
    // Txn.sender.bytes                  +   # 8:40
    // op.itob(price_microalgo.native)   +   # 40:48
    // op.itob(co2_tonnes.native)        +   # 48:56
    // op.itob(vintage_year.native)      +   # 56:64
    // op.itob(min_purchase_qty.native)  +   # 64:72
    concat
    // smart_contracts/marketplace/contract.py:160
    // op.itob(Global.latest_timestamp)  +   # 72:80
    global LatestTimestamp
    itob
    // smart_contracts/marketplace/contract.py:154-160
    // op.itob(asset_id.native)          +   # 0:8
    // Txn.sender.bytes                  +   # 8:40
    // op.itob(price_microalgo.native)   +   # 40:48
    // op.itob(co2_tonnes.native)        +   # 48:56
    // op.itob(vintage_year.native)      +   # 56:64
    // op.itob(min_purchase_qty.native)  +   # 64:72
    // op.itob(Global.latest_timestamp)  +   # 72:80
    concat
    // smart_contracts/marketplace/contract.py:161
    // op.itob(UInt64(1))                +   # 80:88  active=1
    intc_0 // 1
    itob
    // smart_contracts/marketplace/contract.py:154-161
    // op.itob(asset_id.native)          +   # 0:8
    // Txn.sender.bytes                  +   # 8:40
    // op.itob(price_microalgo.native)   +   # 40:48
    // op.itob(co2_tonnes.native)        +   # 48:56
    // op.itob(vintage_year.native)      +   # 56:64
    // op.itob(min_purchase_qty.native)  +   # 64:72
    // op.itob(Global.latest_timestamp)  +   # 72:80
    // op.itob(UInt64(1))                +   # 80:88  active=1
    concat
    // smart_contracts/marketplace/contract.py:154-162
    // op.itob(asset_id.native)          +   # 0:8
    // Txn.sender.bytes                  +   # 8:40
    // op.itob(price_microalgo.native)   +   # 40:48
    // op.itob(co2_tonnes.native)        +   # 48:56
    // op.itob(vintage_year.native)      +   # 56:64
    // op.itob(min_purchase_qty.native)  +   # 64:72
    // op.itob(Global.latest_timestamp)  +   # 72:80
    // op.itob(UInt64(1))                +   # 80:88  active=1
    // ipfs_metadata_hash.bytes,             # 88:end
    uncover 2
    concat
    // smart_contracts/marketplace/contract.py:141-163
    // # Box layout:
    // # offset 0  — asset_id        8 bytes
    // # offset 8  — seller          32 bytes
    // # offset 40 — price           8 bytes
    // # offset 48 — co2_tonnes      8 bytes
    // # offset 56 — vintage_year    8 bytes
    // # offset 64 — min_purchase    8 bytes
    // # offset 72 — timestamp       8 bytes
    // # offset 80 — active          8 bytes  (1=active, 0=sold/cancelled)
    // # offset 88 — ipfs_hash       40 bytes (truncated)
    // # Total: 128 bytes
    // op.Box.put(
    //     op.itob(asset_id.native),
    //     op.itob(asset_id.native)          +   # 0:8
    //     Txn.sender.bytes                  +   # 8:40
    //     op.itob(price_microalgo.native)   +   # 40:48
    //     op.itob(co2_tonnes.native)        +   # 48:56
    //     op.itob(vintage_year.native)      +   # 56:64
    //     op.itob(min_purchase_qty.native)  +   # 64:72
    //     op.itob(Global.latest_timestamp)  +   # 72:80
    //     op.itob(UInt64(1))                +   # 80:88  active=1
    //     ipfs_metadata_hash.bytes,             # 88:end
    // )
    box_put
    // smart_contracts/marketplace/contract.py:103
    // @arc4.abimethod
    intc_0 // 1
    return


// smart_contracts.marketplace.contract.CarbonMarketplace.buy_credit[routing]() -> void:
buy_credit:
    // smart_contracts/marketplace/contract.py:170
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/marketplace/contract.py:182
    // assert Txn.group_index > UInt64(0), "Must be in atomic group"
    txn GroupIndex
    assert // Must be in atomic group
    // smart_contracts/marketplace/contract.py:184-185
    // # Only verified businesses can buy
    // assert self.business_verified[Txn.sender] == UInt64(1), "Business not verified"
    txn Sender
    intc_1 // 0
    bytec_0 // "business_verified"
    app_local_get_ex
    assert // check self.business_verified exists for account
    intc_0 // 1
    ==
    assert // Business not verified
    // smart_contracts/marketplace/contract.py:187-188
    // # Load listing
    // box_value, box_exists = op.Box.get(op.itob(asset_id.native))
    btoi
    dup
    itob
    dup
    box_get
    swap
    dup
    uncover 2
    // smart_contracts/marketplace/contract.py:189
    // assert box_exists, "Listing not found"
    assert // Listing not found
    // smart_contracts/marketplace/contract.py:191
    // seller = Account(op.extract(box_value, 8,  32))
    dup
    extract 8 32
    // smart_contracts/marketplace/contract.py:192
    // price  = op.btoi(op.extract(box_value, 40, 8))
    dig 1
    pushint 40
    extract_uint64
    dup
    cover 2
    cover 3
    // smart_contracts/marketplace/contract.py:193
    // active = op.btoi(op.extract(box_value, 80, 8))
    uncover 2
    pushint 80
    extract_uint64
    // smart_contracts/marketplace/contract.py:195
    // assert active == UInt64(1), "Listing is not active"
    intc_0 // 1
    ==
    assert // Listing is not active
    // smart_contracts/marketplace/contract.py:197-198
    // # Verify payment transaction
    // pay = gtxn.PaymentTransaction(Txn.group_index - UInt64(1))
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/marketplace/contract.py:199
    // assert pay.sender   == Txn.sender,                          "Payment sender mismatch"
    dup
    gtxns Sender
    txn Sender
    ==
    assert // Payment sender mismatch
    // smart_contracts/marketplace/contract.py:200
    // assert pay.receiver == Global.current_application_address,  "Payment must go to contract"
    dup
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Payment must go to contract
    // smart_contracts/marketplace/contract.py:201
    // assert pay.amount   == price,                               "Payment must match price"
    gtxns Amount
    dig 2
    ==
    assert // Payment must match price
    // smart_contracts/marketplace/contract.py:203-204
    // # Fee split
    // platform_fee  = (price * self.platform_fee_bps.value) // UInt64(10000)
    intc_1 // 0
    bytec 6 // "platform_fee_bps"
    app_global_get_ex
    assert // check self.platform_fee_bps exists
    dig 2
    *
    pushint 10000
    /
    dup
    cover 3
    // smart_contracts/marketplace/contract.py:205
    // seller_payout = price - platform_fee
    uncover 2
    dig 1
    -
    // smart_contracts/marketplace/contract.py:207-212
    // # Pay seller
    // itxn.Payment(
    //     receiver = seller,
    //     amount   = seller_payout,
    //     fee      = Global.min_txn_fee,
    // ).submit()
    itxn_begin
    // smart_contracts/marketplace/contract.py:211
    // fee      = Global.min_txn_fee,
    global MinTxnFee
    swap
    itxn_field Amount
    uncover 2
    itxn_field Receiver
    // smart_contracts/marketplace/contract.py:207-208
    // # Pay seller
    // itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/marketplace/contract.py:207-212
    // # Pay seller
    // itxn.Payment(
    //     receiver = seller,
    //     amount   = seller_payout,
    //     fee      = Global.min_txn_fee,
    // ).submit()
    itxn_submit
    // smart_contracts/marketplace/contract.py:214-215
    // # Pay platform fee
    // if platform_fee > UInt64(0):
    bz buy_credit_after_if_else@5
    // smart_contracts/marketplace/contract.py:216-220
    // itxn.Payment(
    //     receiver = self.admin.value,
    //     amount   = platform_fee,
    //     fee      = Global.min_txn_fee,
    // ).submit()
    itxn_begin
    // smart_contracts/marketplace/contract.py:219
    // fee      = Global.min_txn_fee,
    global MinTxnFee
    // smart_contracts/marketplace/contract.py:217
    // receiver = self.admin.value,
    intc_1 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    dig 2
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/marketplace/contract.py:216
    // itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/marketplace/contract.py:216-220
    // itxn.Payment(
    //     receiver = self.admin.value,
    //     amount   = platform_fee,
    //     fee      = Global.min_txn_fee,
    // ).submit()
    itxn_submit

buy_credit_after_if_else@5:
    // smart_contracts/marketplace/contract.py:222-228
    // # Transfer NFT to buyer
    // itxn.AssetTransfer(
    //     xfer_asset     = Asset(asset_id.native),
    //     asset_receiver = Txn.sender,
    //     asset_amount   = 1,
    //     fee            = Global.min_txn_fee,
    // ).submit()
    itxn_begin
    // smart_contracts/marketplace/contract.py:227
    // fee            = Global.min_txn_fee,
    global MinTxnFee
    // smart_contracts/marketplace/contract.py:225
    // asset_receiver = Txn.sender,
    txn Sender
    // smart_contracts/marketplace/contract.py:226
    // asset_amount   = 1,
    intc_0 // 1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    dig 5
    itxn_field XferAsset
    // smart_contracts/marketplace/contract.py:222-223
    // # Transfer NFT to buyer
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/marketplace/contract.py:222-228
    // # Transfer NFT to buyer
    // itxn.AssetTransfer(
    //     xfer_asset     = Asset(asset_id.native),
    //     asset_receiver = Txn.sender,
    //     asset_amount   = 1,
    //     fee            = Global.min_txn_fee,
    // ).submit()
    itxn_submit
    // smart_contracts/marketplace/contract.py:233
    // op.extract(box_value, 0, 80) + op.itob(UInt64(0)) + op.extract(box_value, 88, 40),
    dig 2
    dup
    extract 0 80
    intc_1 // 0
    itob
    concat
    swap
    extract 88 40
    concat
    // smart_contracts/marketplace/contract.py:230-234
    // # Mark listing as sold
    // op.Box.put(
    //     op.itob(asset_id.native),
    //     op.extract(box_value, 0, 80) + op.itob(UInt64(0)) + op.extract(box_value, 88, 40),
    // )
    dig 4
    swap
    box_put
    // smart_contracts/marketplace/contract.py:236-237
    // # Update stats
    // self.total_credits_bought[Txn.sender]     = self.total_credits_bought[Txn.sender] + UInt64(1)
    txn Sender
    intc_1 // 0
    bytec 4 // "total_credits_bought"
    app_local_get_ex
    assert // check self.total_credits_bought exists for account
    intc_0 // 1
    +
    txn Sender
    bytec 4 // "total_credits_bought"
    uncover 2
    app_local_put
    // smart_contracts/marketplace/contract.py:238
    // self.total_volume_microalgo.value          = self.total_volume_microalgo.value + price
    intc_1 // 0
    bytec_2 // "total_volume_microalgo"
    app_global_get_ex
    assert // check self.total_volume_microalgo exists
    dig 2
    +
    bytec_2 // "total_volume_microalgo"
    swap
    app_global_put
    // smart_contracts/marketplace/contract.py:239
    // self.total_trades.value                    = self.total_trades.value + UInt64(1)
    intc_1 // 0
    bytec_3 // "total_trades"
    app_global_get_ex
    assert // check self.total_trades exists
    intc_0 // 1
    +
    bytec_3 // "total_trades"
    swap
    app_global_put
    // smart_contracts/marketplace/contract.py:170
    // @arc4.abimethod
    intc_0 // 1
    return


// smart_contracts.marketplace.contract.CarbonMarketplace.cancel_listing[routing]() -> void:
cancel_listing:
    // smart_contracts/marketplace/contract.py:246
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/marketplace/contract.py:249
    // box_value, box_exists = op.Box.get(op.itob(asset_id.native))
    btoi
    dup
    itob
    dup
    box_get
    // smart_contracts/marketplace/contract.py:250
    // assert box_exists, "Listing not found"
    assert // Listing not found
    // smart_contracts/marketplace/contract.py:252
    // seller = Account(op.extract(box_value, 8,  32))
    dup
    extract 8 32
    // smart_contracts/marketplace/contract.py:253
    // active = op.btoi(op.extract(box_value, 80, 8))
    dig 1
    pushint 80
    extract_uint64
    // smart_contracts/marketplace/contract.py:255
    // assert Txn.sender == seller, "Only seller can cancel"
    txn Sender
    dig 2
    ==
    assert // Only seller can cancel
    // smart_contracts/marketplace/contract.py:256
    // assert active     == UInt64(1), "Listing not active"
    intc_0 // 1
    ==
    assert // Listing not active
    // smart_contracts/marketplace/contract.py:258-264
    // # Return NFT to seller
    // itxn.AssetTransfer(
    //     xfer_asset     = Asset(asset_id.native),
    //     asset_receiver = seller,
    //     asset_amount   = 1,
    //     fee            = Global.min_txn_fee,
    // ).submit()
    itxn_begin
    // smart_contracts/marketplace/contract.py:263
    // fee            = Global.min_txn_fee,
    global MinTxnFee
    // smart_contracts/marketplace/contract.py:262
    // asset_amount   = 1,
    intc_0 // 1
    itxn_field AssetAmount
    swap
    itxn_field AssetReceiver
    uncover 3
    itxn_field XferAsset
    // smart_contracts/marketplace/contract.py:258-259
    // # Return NFT to seller
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/marketplace/contract.py:258-264
    // # Return NFT to seller
    // itxn.AssetTransfer(
    //     xfer_asset     = Asset(asset_id.native),
    //     asset_receiver = seller,
    //     asset_amount   = 1,
    //     fee            = Global.min_txn_fee,
    // ).submit()
    itxn_submit
    // smart_contracts/marketplace/contract.py:269
    // op.extract(box_value, 0, 80) + op.itob(UInt64(0)) + op.extract(box_value, 88, 40),
    dup
    extract 0 80
    intc_1 // 0
    itob
    concat
    swap
    extract 88 40
    concat
    // smart_contracts/marketplace/contract.py:266-270
    // # Mark inactive
    // op.Box.put(
    //     op.itob(asset_id.native),
    //     op.extract(box_value, 0, 80) + op.itob(UInt64(0)) + op.extract(box_value, 88, 40),
    // )
    box_put
    // smart_contracts/marketplace/contract.py:246
    // @arc4.abimethod
    intc_0 // 1
    return


// smart_contracts.marketplace.contract.CarbonMarketplace.get_listing[routing]() -> void:
get_listing:
    // smart_contracts/marketplace/contract.py:277
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/marketplace/contract.py:286
    // box_value, box_exists = op.Box.get(op.itob(asset_id.native))
    btoi
    itob
    box_get
    // smart_contracts/marketplace/contract.py:287
    // assert box_exists, "Listing not found"
    assert // Listing not found
    // smart_contracts/marketplace/contract.py:290
    // arc4.Address(op.extract(box_value, 8,  32)),
    dup
    extract 8 32
    // smart_contracts/marketplace/contract.py:291
    // arc4.UInt64(op.btoi(op.extract(box_value, 40, 8))),
    dig 1
    extract 40 8
    // smart_contracts/marketplace/contract.py:292
    // arc4.UInt64(op.btoi(op.extract(box_value, 48, 8))),
    dig 2
    extract 48 8
    // smart_contracts/marketplace/contract.py:293
    // arc4.UInt64(op.btoi(op.extract(box_value, 64, 8))),
    dig 3
    extract 64 8
    // smart_contracts/marketplace/contract.py:294
    // arc4.UInt64(op.btoi(op.extract(box_value, 80, 8))),
    uncover 4
    extract 80 8
    // smart_contracts/marketplace/contract.py:277
    // @arc4.abimethod(readonly=True)
    uncover 4
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.marketplace.contract.CarbonMarketplace.get_business_status[routing]() -> void:
get_business_status:
    // smart_contracts/marketplace/contract.py:298
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    pushint 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/marketplace/contract.py:308
    // arc4.UInt64(self.business_verified[business.native]),
    dup
    intc_1 // 0
    bytec_0 // "business_verified"
    app_local_get_ex
    assert // check self.business_verified exists for account
    itob
    // smart_contracts/marketplace/contract.py:309
    // arc4.UInt64(self.total_credits_bought[business.native]),
    swap
    intc_1 // 0
    bytec 4 // "total_credits_bought"
    app_local_get_ex
    assert // check self.total_credits_bought exists for account
    itob
    // smart_contracts/marketplace/contract.py:298
    // @arc4.abimethod(readonly=True)
    concat
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.marketplace.contract.CarbonMarketplace.get_stats[routing]() -> void:
get_stats:
    // smart_contracts/marketplace/contract.py:317
    // arc4.UInt64(self.total_volume_microalgo.value // UInt64(1_000_000)),
    intc_1 // 0
    bytec_2 // "total_volume_microalgo"
    app_global_get_ex
    assert // check self.total_volume_microalgo exists
    pushint 1000000
    /
    itob
    // smart_contracts/marketplace/contract.py:318
    // arc4.UInt64(self.total_trades.value),
    intc_1 // 0
    bytec_3 // "total_trades"
    app_global_get_ex
    assert // check self.total_trades exists
    itob
    // smart_contracts/marketplace/contract.py:313
    // @arc4.abimethod(readonly=True)
    concat
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return
