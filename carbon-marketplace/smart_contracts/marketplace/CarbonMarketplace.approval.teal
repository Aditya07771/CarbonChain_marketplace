#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 1 0 8 2
    bytecblock "business_verified" "admin" "total_volume_microalgo" "total_trades" "total_credits_bought" 0x151f7c75 "platform_fee_bps"
    // smart_contracts/marketplace/contract.py:18
    // class CarbonMarketplace(ARC4Contract):
    txn OnCompletion
    !
    assert
    txn ApplicationID
    bz main_create_NoOp@16
    pushbytess 0x191db94e 0xaa5e221f 0x4ba7d851 0xe354224d 0x0063320f 0x63d55b6c 0xe5d86d23 0x863ae2af 0x0b10ef45 0xe67daf51 // method "register_business(string,string)void", method "verify_business(address)void", method "reject_business(address)void", method "list_credit(uint64,uint64,uint64,uint64,string,string,uint64,string,uint64)void", method "buy_credit(uint64)void", method "cancel_listing(uint64)void", method "get_listing(uint64)(address,uint64,uint64,uint64,uint64,uint64)", method "is_listing_expired(uint64)bool", method "get_business_status(address)(uint64,uint64)", method "get_stats()(uint64,uint64)"
    txna ApplicationArgs 0
    match register_business verify_business reject_business list_credit buy_credit cancel_listing get_listing is_listing_expired get_business_status get_stats
    err

main_create_NoOp@16:
    // smart_contracts/marketplace/contract.py:18
    // class CarbonMarketplace(ARC4Contract):
    pushbytes 0xca0b3ceb // method "create_marketplace(uint64)void"
    txna ApplicationArgs 0
    match create_marketplace
    err


// smart_contracts.marketplace.contract.CarbonMarketplace.create_marketplace[routing]() -> void:
create_marketplace:
    // smart_contracts/marketplace/contract.py:46
    // @arc4.abimethod(allow_actions=["NoOp"], create="require")
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/marketplace/contract.py:49
    // self.admin.value                  = Txn.sender
    bytec_1 // "admin"
    txn Sender
    app_global_put
    // smart_contracts/marketplace/contract.py:50
    // self.platform_fee_bps.value       = fee_bps.native
    btoi
    bytec 6 // "platform_fee_bps"
    swap
    app_global_put
    // smart_contracts/marketplace/contract.py:51
    // self.total_volume_microalgo.value = UInt64(0)
    bytec_2 // "total_volume_microalgo"
    intc_1 // 0
    app_global_put
    // smart_contracts/marketplace/contract.py:52
    // self.total_trades.value           = UInt64(0)
    bytec_3 // "total_trades"
    intc_1 // 0
    app_global_put
    // smart_contracts/marketplace/contract.py:46
    // @arc4.abimethod(allow_actions=["NoOp"], create="require")
    intc_0 // 1
    return


// smart_contracts.marketplace.contract.CarbonMarketplace.register_business[routing]() -> void:
register_business:
    // smart_contracts/marketplace/contract.py:59
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 2
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    // smart_contracts/marketplace/contract.py:66
    // self.business_name[Txn.sender]          = name.bytes
    txn Sender
    pushbytes "business_name"
    uncover 3
    app_local_put
    // smart_contracts/marketplace/contract.py:67
    // self.business_country[Txn.sender]        = country.bytes
    txn Sender
    pushbytes "business_country"
    uncover 2
    app_local_put
    // smart_contracts/marketplace/contract.py:68
    // self.business_verified[Txn.sender]       = UInt64(0)
    txn Sender
    bytec_0 // "business_verified"
    intc_1 // 0
    app_local_put
    // smart_contracts/marketplace/contract.py:69
    // self.total_credits_bought[Txn.sender]    = UInt64(0)
    txn Sender
    bytec 4 // "total_credits_bought"
    intc_1 // 0
    app_local_put
    // smart_contracts/marketplace/contract.py:59
    // @arc4.abimethod
    intc_0 // 1
    return


// smart_contracts.marketplace.contract.CarbonMarketplace.verify_business[routing]() -> void:
verify_business:
    // smart_contracts/marketplace/contract.py:72
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    pushint 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/marketplace/contract.py:75
    // assert Txn.sender == self.admin.value, "Admin only"
    txn Sender
    intc_1 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    assert // Admin only
    // smart_contracts/marketplace/contract.py:76
    // self.business_verified[business.native] = UInt64(1)
    bytec_0 // "business_verified"
    intc_0 // 1
    app_local_put
    // smart_contracts/marketplace/contract.py:72
    // @arc4.abimethod
    intc_0 // 1
    return


// smart_contracts.marketplace.contract.CarbonMarketplace.reject_business[routing]() -> void:
reject_business:
    // smart_contracts/marketplace/contract.py:79
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    pushint 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/marketplace/contract.py:82
    // assert Txn.sender == self.admin.value, "Admin only"
    txn Sender
    intc_1 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    assert // Admin only
    // smart_contracts/marketplace/contract.py:83
    // self.business_verified[business.native] = UInt64(2)
    bytec_0 // "business_verified"
    intc_3 // 2
    app_local_put
    // smart_contracts/marketplace/contract.py:79
    // @arc4.abimethod
    intc_0 // 1
    return


// smart_contracts.marketplace.contract.CarbonMarketplace.list_credit[routing]() -> void:
list_credit:
    // smart_contracts/marketplace/contract.py:90
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 5
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 6
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 7
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 8
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 9
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/marketplace/contract.py:117
    // assert price_microalgo.native > UInt64(0),                    "Price must be > 0"
    uncover 4
    btoi
    dup
    assert // Price must be > 0
    // smart_contracts/marketplace/contract.py:118
    // assert min_purchase_qty.native > UInt64(0),                   "Min qty must be > 0"
    uncover 2
    btoi
    dup
    assert // Min qty must be > 0
    // smart_contracts/marketplace/contract.py:119
    // assert min_purchase_qty.native <= co2_tonnes.native,          "Min qty exceeds total"
    uncover 4
    btoi
    dup2
    <=
    assert // Min qty exceeds total
    // smart_contracts/marketplace/contract.py:120
    // assert Txn.group_index > UInt64(0),                           "Must be in atomic group"
    txn GroupIndex
    assert // Must be in atomic group
    // smart_contracts/marketplace/contract.py:122-123
    // # ── Check credit is not already expired ───────────────────
    // assert Global.latest_timestamp < expiry_timestamp.native, "Cannot list an expired credit"
    global LatestTimestamp
    uncover 4
    btoi
    swap
    dig 1
    <
    assert // Cannot list an expired credit
    // smart_contracts/marketplace/contract.py:125-126
    // # ── Verify NFT was sent to contract ───────────────────────
    // prev = gtxn.AssetTransferTransaction(Txn.group_index - UInt64(1))
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    // smart_contracts/marketplace/contract.py:127
    // assert prev.asset_receiver == Global.current_application_address, "NFT must go to contract"
    dup
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert // NFT must go to contract
    // smart_contracts/marketplace/contract.py:128
    // assert prev.xfer_asset.id  == asset_id.native,                    "Wrong asset ID"
    dup
    gtxns XferAsset
    uncover 7
    btoi
    swap
    dig 1
    ==
    assert // Wrong asset ID
    // smart_contracts/marketplace/contract.py:129
    // assert prev.asset_amount   == UInt64(1),                          "Must send exactly 1"
    dig 1
    gtxns AssetAmount
    intc_0 // 1
    ==
    assert // Must send exactly 1
    // smart_contracts/marketplace/contract.py:130
    // assert prev.sender         == Txn.sender,                         "Sender mismatch"
    swap
    gtxns Sender
    txn Sender
    ==
    assert // Sender mismatch
    // smart_contracts/marketplace/contract.py:144
    // op.itob(asset_id.native),
    itob
    // smart_contracts/marketplace/contract.py:145-146
    // op.itob(asset_id.native)          +   # 0:8
    // Txn.sender.bytes                  +   # 8:40
    dup
    // smart_contracts/marketplace/contract.py:146
    // Txn.sender.bytes                  +   # 8:40
    txn Sender
    // smart_contracts/marketplace/contract.py:145-146
    // op.itob(asset_id.native)          +   # 0:8
    // Txn.sender.bytes                  +   # 8:40
    concat
    // smart_contracts/marketplace/contract.py:147
    // op.itob(price_microalgo.native)   +   # 40:48
    uncover 5
    itob
    // smart_contracts/marketplace/contract.py:145-147
    // op.itob(asset_id.native)          +   # 0:8
    // Txn.sender.bytes                  +   # 8:40
    // op.itob(price_microalgo.native)   +   # 40:48
    concat
    // smart_contracts/marketplace/contract.py:148
    // op.itob(co2_tonnes.native)        +   # 48:56
    uncover 3
    itob
    // smart_contracts/marketplace/contract.py:145-148
    // op.itob(asset_id.native)          +   # 0:8
    // Txn.sender.bytes                  +   # 8:40
    // op.itob(price_microalgo.native)   +   # 40:48
    // op.itob(co2_tonnes.native)        +   # 48:56
    concat
    // smart_contracts/marketplace/contract.py:149
    // op.itob(vintage_year.native)      +   # 56:64
    uncover 4
    btoi
    itob
    // smart_contracts/marketplace/contract.py:145-149
    // op.itob(asset_id.native)          +   # 0:8
    // Txn.sender.bytes                  +   # 8:40
    // op.itob(price_microalgo.native)   +   # 40:48
    // op.itob(co2_tonnes.native)        +   # 48:56
    // op.itob(vintage_year.native)      +   # 56:64
    concat
    // smart_contracts/marketplace/contract.py:150
    // op.itob(min_purchase_qty.native)  +   # 64:72
    uncover 3
    itob
    // smart_contracts/marketplace/contract.py:145-150
    // op.itob(asset_id.native)          +   # 0:8
    // Txn.sender.bytes                  +   # 8:40
    // op.itob(price_microalgo.native)   +   # 40:48
    // op.itob(co2_tonnes.native)        +   # 48:56
    // op.itob(vintage_year.native)      +   # 56:64
    // op.itob(min_purchase_qty.native)  +   # 64:72
    concat
    // smart_contracts/marketplace/contract.py:151
    // op.itob(Global.latest_timestamp)  +   # 72:80
    global LatestTimestamp
    itob
    // smart_contracts/marketplace/contract.py:145-151
    // op.itob(asset_id.native)          +   # 0:8
    // Txn.sender.bytes                  +   # 8:40
    // op.itob(price_microalgo.native)   +   # 40:48
    // op.itob(co2_tonnes.native)        +   # 48:56
    // op.itob(vintage_year.native)      +   # 56:64
    // op.itob(min_purchase_qty.native)  +   # 64:72
    // op.itob(Global.latest_timestamp)  +   # 72:80
    concat
    // smart_contracts/marketplace/contract.py:152
    // op.itob(expiry_timestamp.native)  +   # 80:88  ← expiry
    uncover 2
    itob
    // smart_contracts/marketplace/contract.py:145-152
    // op.itob(asset_id.native)          +   # 0:8
    // Txn.sender.bytes                  +   # 8:40
    // op.itob(price_microalgo.native)   +   # 40:48
    // op.itob(co2_tonnes.native)        +   # 48:56
    // op.itob(vintage_year.native)      +   # 56:64
    // op.itob(min_purchase_qty.native)  +   # 64:72
    // op.itob(Global.latest_timestamp)  +   # 72:80
    // op.itob(expiry_timestamp.native)  +   # 80:88  ← expiry
    concat
    // smart_contracts/marketplace/contract.py:153
    // op.itob(UInt64(1)),                   # 88:96  active=1
    intc_0 // 1
    itob
    // smart_contracts/marketplace/contract.py:145-153
    // op.itob(asset_id.native)          +   # 0:8
    // Txn.sender.bytes                  +   # 8:40
    // op.itob(price_microalgo.native)   +   # 40:48
    // op.itob(co2_tonnes.native)        +   # 48:56
    // op.itob(vintage_year.native)      +   # 56:64
    // op.itob(min_purchase_qty.native)  +   # 64:72
    // op.itob(Global.latest_timestamp)  +   # 72:80
    // op.itob(expiry_timestamp.native)  +   # 80:88  ← expiry
    // op.itob(UInt64(1)),                   # 88:96  active=1
    concat
    // smart_contracts/marketplace/contract.py:132-154
    // # Box layout:
    // # offset 0  — asset_id        8 bytes
    // # offset 8  — seller          32 bytes
    // # offset 40 — price           8 bytes
    // # offset 48 — co2_tonnes      8 bytes
    // # offset 56 — vintage_year    8 bytes
    // # offset 64 — min_purchase    8 bytes
    // # offset 72 — listed_at       8 bytes
    // # offset 80 — expiry          8 bytes  ← NEW
    // # offset 88 — active          8 bytes
    // # Total: 96 bytes
    // op.Box.put(
    //     op.itob(asset_id.native),
    //     op.itob(asset_id.native)          +   # 0:8
    //     Txn.sender.bytes                  +   # 8:40
    //     op.itob(price_microalgo.native)   +   # 40:48
    //     op.itob(co2_tonnes.native)        +   # 48:56
    //     op.itob(vintage_year.native)      +   # 56:64
    //     op.itob(min_purchase_qty.native)  +   # 64:72
    //     op.itob(Global.latest_timestamp)  +   # 72:80
    //     op.itob(expiry_timestamp.native)  +   # 80:88  ← expiry
    //     op.itob(UInt64(1)),                   # 88:96  active=1
    // )
    box_put
    // smart_contracts/marketplace/contract.py:90
    // @arc4.abimethod
    intc_0 // 1
    return


// smart_contracts.marketplace.contract.CarbonMarketplace.buy_credit[routing]() -> void:
buy_credit:
    // smart_contracts/marketplace/contract.py:161
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/marketplace/contract.py:176
    // assert Txn.group_index > UInt64(0),                              "Must be in atomic group"
    txn GroupIndex
    assert // Must be in atomic group
    // smart_contracts/marketplace/contract.py:177
    // assert self.business_verified[Txn.sender] == UInt64(1),          "Business not verified"
    txn Sender
    intc_1 // 0
    bytec_0 // "business_verified"
    app_local_get_ex
    assert // check self.business_verified exists for account
    intc_0 // 1
    ==
    assert // Business not verified
    // smart_contracts/marketplace/contract.py:179-180
    // # Load listing
    // box_value, box_exists = op.Box.get(op.itob(asset_id.native))
    btoi
    dup
    itob
    dup
    box_get
    swap
    dup
    uncover 2
    // smart_contracts/marketplace/contract.py:181
    // assert box_exists, "Listing not found"
    assert // Listing not found
    // smart_contracts/marketplace/contract.py:183
    // seller          = Account(op.extract(box_value, 8,  32))
    dup
    extract 8 32
    // smart_contracts/marketplace/contract.py:184
    // price           = op.btoi(op.extract(box_value, 40, 8))
    dig 1
    pushint 40
    extract_uint64
    dup
    cover 2
    cover 3
    // smart_contracts/marketplace/contract.py:185
    // expiry          = op.btoi(op.extract(box_value, 80, 8))   # ← NEW
    dig 2
    pushint 80
    extract_uint64
    // smart_contracts/marketplace/contract.py:186
    // active          = op.btoi(op.extract(box_value, 88, 8))
    uncover 3
    pushint 88
    extract_uint64
    // smart_contracts/marketplace/contract.py:188
    // assert active == UInt64(1), "Listing is not active"
    intc_0 // 1
    ==
    assert // Listing is not active
    // smart_contracts/marketplace/contract.py:190-192
    // # ── EXPIRY CHECK (enforced on-chain) ──────────────────────
    // # Global.latest_timestamp = current block time (cannot be faked)
    // assert Global.latest_timestamp < expiry, "This carbon credit has expired and cannot be sold"
    global LatestTimestamp
    >
    assert // This carbon credit has expired and cannot be sold
    // smart_contracts/marketplace/contract.py:194-195
    // # Verify payment
    // pay = gtxn.PaymentTransaction(Txn.group_index - UInt64(1))
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/marketplace/contract.py:196
    // assert pay.sender   == Txn.sender,                           "Payment sender mismatch"
    dup
    gtxns Sender
    txn Sender
    ==
    assert // Payment sender mismatch
    // smart_contracts/marketplace/contract.py:197
    // assert pay.receiver == Global.current_application_address,   "Wrong receiver"
    dup
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Wrong receiver
    // smart_contracts/marketplace/contract.py:198
    // assert pay.amount   == price,                                "Wrong payment amount"
    gtxns Amount
    dig 2
    ==
    assert // Wrong payment amount
    // smart_contracts/marketplace/contract.py:200-201
    // # Fee split
    // platform_fee  = (price * self.platform_fee_bps.value) // UInt64(10000)
    intc_1 // 0
    bytec 6 // "platform_fee_bps"
    app_global_get_ex
    assert // check self.platform_fee_bps exists
    dig 2
    *
    pushint 10000
    /
    dup
    cover 3
    // smart_contracts/marketplace/contract.py:202
    // seller_payout = price - platform_fee
    uncover 2
    dig 1
    -
    // smart_contracts/marketplace/contract.py:204-209
    // # Pay seller
    // itxn.Payment(
    //     receiver = seller,
    //     amount   = seller_payout,
    //     fee      = Global.min_txn_fee,
    // ).submit()
    itxn_begin
    // smart_contracts/marketplace/contract.py:208
    // fee      = Global.min_txn_fee,
    global MinTxnFee
    swap
    itxn_field Amount
    uncover 2
    itxn_field Receiver
    // smart_contracts/marketplace/contract.py:204-205
    // # Pay seller
    // itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/marketplace/contract.py:204-209
    // # Pay seller
    // itxn.Payment(
    //     receiver = seller,
    //     amount   = seller_payout,
    //     fee      = Global.min_txn_fee,
    // ).submit()
    itxn_submit
    // smart_contracts/marketplace/contract.py:211-212
    // # Pay platform fee
    // if platform_fee > UInt64(0):
    bz buy_credit_after_if_else@5
    // smart_contracts/marketplace/contract.py:213-217
    // itxn.Payment(
    //     receiver = self.admin.value,
    //     amount   = platform_fee,
    //     fee      = Global.min_txn_fee,
    // ).submit()
    itxn_begin
    // smart_contracts/marketplace/contract.py:216
    // fee      = Global.min_txn_fee,
    global MinTxnFee
    // smart_contracts/marketplace/contract.py:214
    // receiver = self.admin.value,
    intc_1 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    dig 2
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/marketplace/contract.py:213
    // itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/marketplace/contract.py:213-217
    // itxn.Payment(
    //     receiver = self.admin.value,
    //     amount   = platform_fee,
    //     fee      = Global.min_txn_fee,
    // ).submit()
    itxn_submit

buy_credit_after_if_else@5:
    // smart_contracts/marketplace/contract.py:219-225
    // # Transfer NFT to buyer
    // itxn.AssetTransfer(
    //     xfer_asset     = Asset(asset_id.native),
    //     asset_receiver = Txn.sender,
    //     asset_amount   = 1,
    //     fee            = Global.min_txn_fee,
    // ).submit()
    itxn_begin
    // smart_contracts/marketplace/contract.py:224
    // fee            = Global.min_txn_fee,
    global MinTxnFee
    // smart_contracts/marketplace/contract.py:222
    // asset_receiver = Txn.sender,
    txn Sender
    // smart_contracts/marketplace/contract.py:223
    // asset_amount   = 1,
    intc_0 // 1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    dig 5
    itxn_field XferAsset
    // smart_contracts/marketplace/contract.py:219-220
    // # Transfer NFT to buyer
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/marketplace/contract.py:219-225
    // # Transfer NFT to buyer
    // itxn.AssetTransfer(
    //     xfer_asset     = Asset(asset_id.native),
    //     asset_receiver = Txn.sender,
    //     asset_amount   = 1,
    //     fee            = Global.min_txn_fee,
    // ).submit()
    itxn_submit
    // smart_contracts/marketplace/contract.py:230
    // op.extract(box_value, 0, 88) + op.itob(UInt64(0)),
    dig 2
    extract 0 88
    intc_1 // 0
    itob
    concat
    // smart_contracts/marketplace/contract.py:227-231
    // # Mark listing as sold (active = 0)
    // op.Box.put(
    //     op.itob(asset_id.native),
    //     op.extract(box_value, 0, 88) + op.itob(UInt64(0)),
    // )
    dig 4
    swap
    box_put
    // smart_contracts/marketplace/contract.py:233
    // self.total_credits_bought[Txn.sender]     = self.total_credits_bought[Txn.sender] + UInt64(1)
    txn Sender
    intc_1 // 0
    bytec 4 // "total_credits_bought"
    app_local_get_ex
    assert // check self.total_credits_bought exists for account
    intc_0 // 1
    +
    txn Sender
    bytec 4 // "total_credits_bought"
    uncover 2
    app_local_put
    // smart_contracts/marketplace/contract.py:234
    // self.total_volume_microalgo.value          = self.total_volume_microalgo.value + price
    intc_1 // 0
    bytec_2 // "total_volume_microalgo"
    app_global_get_ex
    assert // check self.total_volume_microalgo exists
    dig 2
    +
    bytec_2 // "total_volume_microalgo"
    swap
    app_global_put
    // smart_contracts/marketplace/contract.py:235
    // self.total_trades.value                    = self.total_trades.value + UInt64(1)
    intc_1 // 0
    bytec_3 // "total_trades"
    app_global_get_ex
    assert // check self.total_trades exists
    intc_0 // 1
    +
    bytec_3 // "total_trades"
    swap
    app_global_put
    // smart_contracts/marketplace/contract.py:161
    // @arc4.abimethod
    intc_0 // 1
    return


// smart_contracts.marketplace.contract.CarbonMarketplace.cancel_listing[routing]() -> void:
cancel_listing:
    // smart_contracts/marketplace/contract.py:242
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/marketplace/contract.py:245
    // box_value, box_exists = op.Box.get(op.itob(asset_id.native))
    btoi
    dup
    itob
    dup
    box_get
    // smart_contracts/marketplace/contract.py:246
    // assert box_exists, "Listing not found"
    assert // Listing not found
    // smart_contracts/marketplace/contract.py:248
    // seller = Account(op.extract(box_value, 8,  32))
    dup
    extract 8 32
    // smart_contracts/marketplace/contract.py:249
    // active = op.btoi(op.extract(box_value, 88, 8))
    dig 1
    pushint 88
    extract_uint64
    // smart_contracts/marketplace/contract.py:251
    // assert Txn.sender == seller, "Only seller can cancel"
    txn Sender
    dig 2
    ==
    assert // Only seller can cancel
    // smart_contracts/marketplace/contract.py:252
    // assert active == UInt64(1),  "Listing not active"
    intc_0 // 1
    ==
    assert // Listing not active
    // smart_contracts/marketplace/contract.py:254-259
    // itxn.AssetTransfer(
    //     xfer_asset     = Asset(asset_id.native),
    //     asset_receiver = seller,
    //     asset_amount   = 1,
    //     fee            = Global.min_txn_fee,
    // ).submit()
    itxn_begin
    // smart_contracts/marketplace/contract.py:258
    // fee            = Global.min_txn_fee,
    global MinTxnFee
    // smart_contracts/marketplace/contract.py:257
    // asset_amount   = 1,
    intc_0 // 1
    itxn_field AssetAmount
    swap
    itxn_field AssetReceiver
    uncover 3
    itxn_field XferAsset
    // smart_contracts/marketplace/contract.py:254
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/marketplace/contract.py:254-259
    // itxn.AssetTransfer(
    //     xfer_asset     = Asset(asset_id.native),
    //     asset_receiver = seller,
    //     asset_amount   = 1,
    //     fee            = Global.min_txn_fee,
    // ).submit()
    itxn_submit
    // smart_contracts/marketplace/contract.py:263
    // op.extract(box_value, 0, 88) + op.itob(UInt64(0)),
    extract 0 88
    intc_1 // 0
    itob
    concat
    // smart_contracts/marketplace/contract.py:261-264
    // op.Box.put(
    //     op.itob(asset_id.native),
    //     op.extract(box_value, 0, 88) + op.itob(UInt64(0)),
    // )
    box_put
    // smart_contracts/marketplace/contract.py:242
    // @arc4.abimethod
    intc_0 // 1
    return


// smart_contracts.marketplace.contract.CarbonMarketplace.get_listing[routing]() -> void:
get_listing:
    // smart_contracts/marketplace/contract.py:271
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/marketplace/contract.py:283
    // box_value, box_exists = op.Box.get(op.itob(asset_id.native))
    btoi
    itob
    box_get
    // smart_contracts/marketplace/contract.py:284
    // assert box_exists, "Listing not found"
    assert // Listing not found
    // smart_contracts/marketplace/contract.py:287
    // arc4.Address(op.extract(box_value, 8,  32)),
    dup
    extract 8 32
    // smart_contracts/marketplace/contract.py:288
    // arc4.UInt64(op.btoi(op.extract(box_value, 40, 8))),
    dig 1
    extract 40 8
    // smart_contracts/marketplace/contract.py:289
    // arc4.UInt64(op.btoi(op.extract(box_value, 48, 8))),
    dig 2
    extract 48 8
    // smart_contracts/marketplace/contract.py:290
    // arc4.UInt64(op.btoi(op.extract(box_value, 64, 8))),
    dig 3
    extract 64 8
    // smart_contracts/marketplace/contract.py:291
    // arc4.UInt64(op.btoi(op.extract(box_value, 80, 8))),
    dig 4
    extract 80 8
    // smart_contracts/marketplace/contract.py:292
    // arc4.UInt64(op.btoi(op.extract(box_value, 88, 8))),
    uncover 5
    extract 88 8
    // smart_contracts/marketplace/contract.py:271
    // @arc4.abimethod(readonly=True)
    uncover 5
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.marketplace.contract.CarbonMarketplace.is_listing_expired[routing]() -> void:
is_listing_expired:
    // smart_contracts/marketplace/contract.py:296
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // smart_contracts/marketplace/contract.py:302
    // box_value, box_exists = op.Box.get(op.itob(asset_id.native))
    btoi
    itob
    box_get
    // smart_contracts/marketplace/contract.py:303
    // assert box_exists, "Listing not found"
    assert // Listing not found
    pushint 80
    // smart_contracts/marketplace/contract.py:305
    // expiry = op.btoi(op.extract(box_value, 80, 8))
    extract_uint64
    // smart_contracts/marketplace/contract.py:306
    // return arc4.Bool(Global.latest_timestamp > expiry)
    global LatestTimestamp
    <
    pushbytes 0x00
    intc_1 // 0
    uncover 2
    setbit
    // smart_contracts/marketplace/contract.py:296
    // @arc4.abimethod(readonly=True)
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.marketplace.contract.CarbonMarketplace.get_business_status[routing]() -> void:
get_business_status:
    // smart_contracts/marketplace/contract.py:309
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    pushint 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/marketplace/contract.py:316
    // arc4.UInt64(self.business_verified[business.native]),
    dup
    intc_1 // 0
    bytec_0 // "business_verified"
    app_local_get_ex
    assert // check self.business_verified exists for account
    itob
    // smart_contracts/marketplace/contract.py:317
    // arc4.UInt64(self.total_credits_bought[business.native]),
    swap
    intc_1 // 0
    bytec 4 // "total_credits_bought"
    app_local_get_ex
    assert // check self.total_credits_bought exists for account
    itob
    // smart_contracts/marketplace/contract.py:309
    // @arc4.abimethod(readonly=True)
    concat
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.marketplace.contract.CarbonMarketplace.get_stats[routing]() -> void:
get_stats:
    // smart_contracts/marketplace/contract.py:325
    // arc4.UInt64(self.total_volume_microalgo.value // UInt64(1_000_000)),
    intc_1 // 0
    bytec_2 // "total_volume_microalgo"
    app_global_get_ex
    assert // check self.total_volume_microalgo exists
    pushint 1000000
    /
    itob
    // smart_contracts/marketplace/contract.py:326
    // arc4.UInt64(self.total_trades.value),
    intc_1 // 0
    bytec_3 // "total_trades"
    app_global_get_ex
    assert // check self.total_trades exists
    itob
    // smart_contracts/marketplace/contract.py:321
    // @arc4.abimethod(readonly=True)
    concat
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return
